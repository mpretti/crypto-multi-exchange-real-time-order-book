<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Pairs Explorer - Multi-Exchange Data</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Main Header Styles */
        .main-header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .main-header h1 {
            font-size: 2rem;
            margin: 0;
            color: #333;
            font-weight: 700;
        }

        .navigation {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .nav-link {
            padding: 10px 20px;
            text-decoration: none;
            color: #666;
            font-weight: 500;
            border-radius: 8px;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .nav-link:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            transform: translateY(-2px);
        }

        .nav-link.active {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h2 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0,0,0,0.15);
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .stat-label {
            font-size: 1rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .controls h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
        }

        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .filter-group input, .filter-group select {
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .filter-group input:focus, .filter-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .exchange-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        .exchange-chip {
            padding: 8px 16px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            font-weight: 500;
        }

        .exchange-chip.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .exchange-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Searchable Dropdown Styles */
        .searchable-dropdown {
            position: relative;
            width: 100%;
        }

        .dropdown-input {
            position: relative;
            display: flex;
            align-items: center;
        }

        .dropdown-input input {
            width: 100%;
            padding: 12px 40px 12px 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: border-color 0.3s ease;
            background: white;
        }

        .dropdown-input input:focus {
            outline: none;
            border-color: #667eea;
            cursor: text;
        }

        .dropdown-input input[readonly] {
            cursor: pointer;
        }

        .dropdown-arrow {
            position: absolute;
            right: 12px;
            font-size: 12px;
            color: #666;
            pointer-events: none;
            transition: transform 0.3s ease;
        }

        .searchable-dropdown.open .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e1e5e9;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .searchable-dropdown.open .dropdown-options {
            display: block;
        }

        .dropdown-option {
            padding: 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid #f1f3f4;
        }

        .dropdown-option:last-child {
            border-bottom: none;
        }

        .dropdown-option:hover {
            background-color: #f8f9fa;
        }

        .dropdown-option.selected {
            background-color: #667eea;
            color: white;
        }

        .dropdown-option.pinned {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            font-weight: 600;
        }

        .dropdown-option.pinned:hover {
            background-color: #ffeaa7;
        }

        .dropdown-section-header {
            padding: 8px 12px;
            background-color: #f8f9fa;
            font-weight: 600;
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #e9ecef;
        }

        .dropdown-options::-webkit-scrollbar {
            width: 6px;
        }

        .dropdown-options::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .dropdown-options::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .dropdown-options::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .results-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .results-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .results-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .results-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
        }

        .table-container {
            max-height: 600px;
            overflow-y: auto;
        }

        .pairs-table {
            width: 100%;
            border-collapse: collapse;
        }

        .pairs-table th {
            background: #f8f9fa;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #e9ecef;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .pairs-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e9ecef;
            transition: background-color 0.2s ease;
        }

        .pairs-table tr:hover {
            background-color: #f8f9fa;
        }

        .exchange-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: white;
            margin-right: 5px;
            margin-bottom: 2px;
        }

        .trading-type-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 500;
            margin-right: 4px;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .trading-type-badge.spot {
            background: #28a745;
            color: white;
        }

        .trading-type-badge.perpetual {
            background: #007bff;
            color: white;
        }

        .trading-type-badge.futures {
            background: #ffc107;
            color: #212529;
        }

        .trading-type-badge.swap {
            background: #17a2b8;
            color: white;
        }

        .trading-type-badge.inverse {
            background: #6f42c1;
            color: white;
        }

        .trading-type-badge.linear {
            background: #fd7e14;
            color: white;
        }

        .symbol-cell {
            font-weight: 600;
            color: #333;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .top-pairs {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .top-pairs h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
        }

        .top-pairs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }

        .top-pair-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .pair-name {
            font-weight: 600;
            color: #333;
        }

        .pair-count {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .main-header {
                padding: 15px 20px;
            }

            .header-top-row {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .main-header h1 {
                font-size: 1.5rem;
                text-align: center;
            }

            .navigation {
                justify-content: center;
                flex-wrap: wrap;
                gap: 10px;
            }

            .nav-link {
                padding: 8px 15px;
                font-size: 0.9rem;
                text-align: center;
                min-width: 100px;
            }

            .header h2 {
                font-size: 2rem;
            }

            .header p {
                font-size: 1rem;
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 15px;
            }

            .filter-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .exchange-filters {
                justify-content: center;
            }

            .table-container {
                font-size: 0.9rem;
            }

            .pairs-table th,
            .pairs-table td {
                padding: 8px 4px;
            }
        }

        @media (max-width: 480px) {
            .main-header h1 {
                font-size: 1.3rem;
            }

            .navigation {
                gap: 8px;
            }

            .nav-link {
                padding: 6px 12px;
                font-size: 0.8rem;
                min-width: 80px;
            }

            .header h2 {
                font-size: 1.8rem;
            }

            .stat-card {
                padding: 15px;
            }

            .stat-number {
                font-size: 2rem;
            }
        }

        /* Styles for futures contract indicators */
    </style>
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="header-top-row">
                <h1>Trading Pairs Explorer</h1>
                <nav class="navigation">
                    <a href="index.html" class="nav-link">‚Üê Order Book</a>
                    <a href="charts-dashboard.html" class="nav-link">Charts</a>
                    <a href="volume-dashboard.html" class="nav-link">Volume Dashboard</a>
                    <a href="exchange-status.html" class="nav-link">Exchange Status</a>
                    <a href="trading-pairs-explorer.html" class="nav-link active">Trading Pairs</a>
                </nav>
            </div>
        </header>

        <div class="header">
            <h2>Multi-Exchange Trading Pairs Data</h2>
            <p>Explore and analyze trading pairs across multiple cryptocurrency exchanges</p>
        </div>

        <div class="stats-grid" id="statsGrid">
            <div class="stat-card">
                <div class="stat-number" id="totalPairs">-</div>
                <div class="stat-label">Total Pairs</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalExchanges">-</div>
                <div class="stat-label">Exchanges</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="uniquePairs">-</div>
                <div class="stat-label">Unique Symbols</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="lastUpdated">-</div>
                <div class="stat-label">Last Updated</div>
            </div>
        </div>

        <div class="top-pairs">
            <h3>üèÜ Most Popular Trading Pairs</h3>
            <div class="top-pairs-grid" id="topPairsGrid">
                <!-- Top pairs will be populated here -->
            </div>
        </div>

        <div class="controls">
            <h3>üîç Search & Filter</h3>
            <div class="filter-grid">
                <div class="filter-group">
                    <label for="searchInput">Search Symbol:</label>
                    <input type="text" id="searchInput" placeholder="e.g., BTC, ETH, USDT...">
                </div>
                <div class="filter-group">
                    <label for="sortBy">Sort By:</label>
                    <select id="sortBy">
                        <option value="symbol">Symbol (A-Z)</option>
                        <option value="exchanges">Exchange Count</option>
                        <option value="volume">24h Volume</option>
                        <option value="baseAsset">Base Asset</option>
                        <option value="quoteAsset">Quote Asset</option>
                        <option value="tradingType">Trading Type</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="quoteFilter">Quote Asset:</label>
                    <div class="searchable-dropdown" id="quoteDropdown">
                        <div class="dropdown-input">
                            <input type="text" id="quoteFilter" placeholder="All Quote Assets" readonly>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="dropdown-options" id="quoteOptions">
                            <div class="dropdown-option" data-value="">All Quote Assets</div>
                        </div>
                    </div>
                </div>
                <div class="filter-group">
                    <label for="baseFilter">Base Asset</label>
                    <div class="dropdown" id="baseDropdown">
                        <input type="text" id="baseFilter" placeholder="All Base Assets" readonly>
                        <div class="dropdown-options" id="baseOptions"></div>
                    </div>
                </div>
                
                <!-- New Trading Type Filter -->
                <div class="filter-group">
                    <label style="margin-bottom: 10px; display: block; font-weight: 600; color: #555;">Trading Type</label>
                    <div class="exchange-filters" id="tradingTypeFilters">
                        <!-- Trading type filters will be populated here -->
                    </div>
                </div>
            </div>
            
            <div>
                <label style="margin-bottom: 10px; display: block; font-weight: 600; color: #555;">Filter by Exchange:</label>
                <div class="exchange-filters" id="exchangeFilters">
                    <!-- Exchange filters will be populated here -->
                </div>
            </div>
        </div>

        <div class="results-container">
            <div class="results-header">
                <div class="results-title">Trading Pairs</div>
                <div class="results-count" id="resultsCount">Loading...</div>
            </div>
            <div class="table-container">
                <table class="pairs-table">
                    <thead>
                        <tr>
                            <th>Symbol</th>
                            <th>Base Asset</th>
                            <th>Quote Asset</th>
                            <th>Trading Type</th>
                            <th>24h Volume</th>
                            <th>Available On</th>
                            <th>Exchange Count</th>
                        </tr>
                    </thead>
                    <tbody id="pairsTableBody">
                        <tr>
                            <td colspan="7" class="loading">Loading trading pairs data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        class TradingPairsExplorer {
            constructor() {
                this.allData = {};
                this.processedPairs = [];
                this.filteredPairs = [];
                this.selectedExchanges = new Set();
                this.selectedTradingTypes = new Set();
                this.volumeCache = new Map();
                this.volumeUpdateInterval = null;
                this.exchangeColors = {
                    'binance': '#f0b90b',
                    'bybit': '#f7931a',
                    'okx': '#0052ff',
                    'kraken': '#5741d9',
                    'bitget': '#00d4aa',
                    'coinbase': '#0052ff',
                    'gemini': '#00dcfa',
                    'bitrue': '#0088cc',
                    'hyperliquid': '#ff6b35',
                    'dydx': '#6966ff',
                    'vertex': '#7c3aed',
                    'jupiter': '#ffa500'
                };
                this.init();
            }

            async init() {
                try {
                    await this.loadData();
                    this.processData();
                    this.setupEventListeners();
                    this.updateDisplay();
                    this.startVolumeUpdates();
                } catch (error) {
                    this.showError('Failed to load trading pairs data: ' + error.message);
                }
            }

            async loadData() {
                const response = await fetch('./trading-pairs/all-exchanges-pairs.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                this.allData = await response.json();
            }

            processData() {
                const pairMap = new Map();
                
                // Process all pairs and group by normalized symbol
                for (const [exchangeId, exchangeData] of Object.entries(this.allData)) {
                    for (const pair of exchangeData.pairs) {
                        const normalizedSymbol = this.normalizeSymbol(pair.symbol);
                        
                        if (!pairMap.has(normalizedSymbol)) {
                            pairMap.set(normalizedSymbol, {
                                symbol: normalizedSymbol,
                                baseAsset: this.extractBaseAsset(pair),
                                quoteAsset: this.extractQuoteAsset(pair),
                                tradingTypes: new Set(),
                                exchanges: [],
                                exchangeCount: 0,
                                rawPairs: []
                            });
                        }
                        
                        const pairData = pairMap.get(normalizedSymbol);
                        const tradingType = this.extractTradingType(pair);
                        pairData.tradingTypes.add(tradingType);
                        pairData.exchanges.push({
                            id: exchangeId,
                            name: exchangeData.exchange,
                            originalSymbol: pair.symbol,
                            tradingType: tradingType
                        });
                        pairData.rawPairs.push({ ...pair, exchangeId, exchangeName: exchangeData.exchange, tradingType });
                        pairData.exchangeCount = pairData.exchanges.length;
                    }
                }
                
                this.processedPairs = Array.from(pairMap.values());
                this.filteredPairs = [...this.processedPairs];
                
                // Debug: Log trading type distribution
                const typeStats = {};
                this.processedPairs.forEach(pair => {
                    pair.tradingTypes.forEach(type => {
                        typeStats[type] = (typeStats[type] || 0) + 1;
                    });
                });
                console.log('Trading type distribution:', typeStats);
                console.log('Total processed pairs:', this.processedPairs.length);
                
                // Initialize all exchanges as selected
                this.selectedExchanges = new Set(Object.keys(this.allData));
                
                // Initialize all trading types as selected
                const allTradingTypes = new Set();
                this.processedPairs.forEach(pair => {
                    pair.tradingTypes.forEach(type => allTradingTypes.add(type));
                });
                this.selectedTradingTypes = new Set(allTradingTypes);
            }

            extractTradingType(pair) {
                // Extract trading type from various possible fields
                const contractType = pair.contractType || pair.type || pair.instType || '';
                const symbol = pair.symbol || '';
                
                // Normalize the contract type to standard categories
                const type = contractType.toLowerCase();
                
                let result;
                if (type.includes('perpetual') || type.includes('perp')) {
                    result = 'perpetual';
                } else if (type.includes('futures') || type.includes('future')) {
                    result = 'futures';
                } else if (type.includes('swap')) {
                    result = 'swap';
                } else if (type.includes('inverse')) {
                    result = 'inverse';
                } else if (type.includes('linear')) {
                    result = 'linear';
                } else if (symbol.includes('-') && (symbol.includes('25') || symbol.includes('26') || symbol.includes('24'))) {
                    // Date-based futures contracts
                    result = 'futures';
                } else if (!contractType || contractType === 'SPOT' || type === 'spot') {
                    result = 'spot';
                } else {
                    // Default to spot if no clear type is identified
                    result = 'spot';
                }
                
                // Debug logging for first few pairs
                if (Math.random() < 0.01) { // Log ~1% of pairs for debugging
                    console.log(`Trading type extraction: ${symbol} -> ${contractType} -> ${result}`);
                }
                
                return result;
            }

            normalizeSymbol(symbol) {
                // Remove common separators and normalize
                return symbol.replace(/[-_\/]/g, '').toUpperCase();
            }

            extractBaseAsset(pair) {
                if (pair.baseAsset || pair.baseCoin || pair.baseCcy) {
                    return pair.baseAsset || pair.baseCoin || pair.baseCcy;
                }
                
                // Try to extract from symbol
                const symbol = pair.symbol.replace(/[-_\/]/g, '');
                if (symbol.includes('USDT')) {
                    return symbol.replace('USDT', '');
                } else if (symbol.includes('USDC')) {
                    return symbol.replace('USDC', '');
                } else if (symbol.includes('BTC')) {
                    return symbol.replace('BTC', '');
                } else if (symbol.includes('ETH')) {
                    return symbol.replace('ETH', '');
                }
                
                return symbol.slice(0, -3); // Fallback: assume last 3 chars are quote
            }

            extractQuoteAsset(pair) {
                if (pair.quoteAsset || pair.quoteCoin || pair.quoteCcy) {
                    return pair.quoteAsset || pair.quoteCoin || pair.quoteCcy;
                }
                
                // Try to extract from symbol
                const symbol = pair.symbol.replace(/[-_\/]/g, '');
                if (symbol.includes('USDT')) {
                    return 'USDT';
                } else if (symbol.includes('USDC')) {
                    return 'USDC';
                } else if (symbol.includes('BTC')) {
                    return 'BTC';
                } else if (symbol.includes('ETH')) {
                    return 'ETH';
                }
                
                return symbol.slice(-3); // Fallback: assume last 3 chars are quote
            }

            setupEventListeners() {
                document.getElementById('searchInput').addEventListener('input', () => this.applyFilters());
                document.getElementById('sortBy').addEventListener('change', () => this.applyFilters());
                
                // Setup searchable dropdowns
                this.setupSearchableDropdown('quote');
                this.setupSearchableDropdown('base');
            }

            updateDisplay() {
                this.updateStats();
                this.updateTopPairs();
                this.updateExchangeFilters();
                this.updateTradingTypeFilters();
                this.updateFilterOptions();
                this.applyFilters();
            }

            updateStats() {
                const totalPairs = Object.values(this.allData).reduce((sum, exchange) => sum + exchange.count, 0);
                const totalExchanges = Object.keys(this.allData).length;
                const uniquePairs = this.processedPairs.length;
                
                // Get most recent update
                const lastUpdated = Object.values(this.allData)
                    .map(exchange => new Date(exchange.lastUpdated))
                    .sort((a, b) => b - a)[0];

                document.getElementById('totalPairs').textContent = totalPairs.toLocaleString();
                document.getElementById('totalExchanges').textContent = totalExchanges;
                document.getElementById('uniquePairs').textContent = uniquePairs.toLocaleString();
                document.getElementById('lastUpdated').textContent = lastUpdated.toLocaleDateString();
            }

            updateTopPairs() {
                const topPairs = this.processedPairs
                    .sort((a, b) => b.exchangeCount - a.exchangeCount)
                    .slice(0, 12);

                const grid = document.getElementById('topPairsGrid');
                grid.innerHTML = topPairs.map(pair => `
                    <div class="top-pair-item">
                        <span class="pair-name">${pair.symbol}</span>
                        <span class="pair-count">${pair.exchangeCount} exchanges</span>
                    </div>
                `).join('');
            }

            updateExchangeFilters() {
                const container = document.getElementById('exchangeFilters');
                container.innerHTML = Object.entries(this.allData).map(([id, data]) => `
                    <div class="exchange-chip active" data-exchange="${id}">
                        ${data.exchange} (${data.count})
                    </div>
                `).join('');

                // Add click handlers
                container.querySelectorAll('.exchange-chip').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const exchangeId = chip.dataset.exchange;
                        if (this.selectedExchanges.has(exchangeId)) {
                            this.selectedExchanges.delete(exchangeId);
                            chip.classList.remove('active');
                        } else {
                            this.selectedExchanges.add(exchangeId);
                            chip.classList.add('active');
                        }
                        this.applyFilters();
                    });
                });
            }

            updateTradingTypeFilters() {
                // Calculate counts for each trading type
                const typeCounts = {};
                this.processedPairs.forEach(pair => {
                    pair.tradingTypes.forEach(type => {
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    });
                });

                // Create trading type chips
                const container = document.getElementById('tradingTypeFilters');
                const typeOrder = ['spot', 'perpetual', 'futures', 'swap', 'linear', 'inverse'];
                const sortedTypes = Object.keys(typeCounts).sort((a, b) => {
                    const aIndex = typeOrder.indexOf(a);
                    const bIndex = typeOrder.indexOf(b);
                    if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
                    if (aIndex === -1) return 1;
                    if (bIndex === -1) return -1;
                    return aIndex - bIndex;
                });

                container.innerHTML = [
                    `<div class="exchange-chip active" data-type="">All Types (${this.processedPairs.length})</div>`,
                    ...sortedTypes.map(type => `
                        <div class="exchange-chip active" data-type="${type}">
                            ${type.charAt(0).toUpperCase() + type.slice(1)} (${typeCounts[type]})
                        </div>
                    `)
                ].join('');

                // Add click handlers
                container.querySelectorAll('.exchange-chip').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const typeId = chip.dataset.type;
                        
                        if (typeId === '') {
                            // "All Types" clicked - toggle all
                            if (this.selectedTradingTypes.size === sortedTypes.length) {
                                // All selected, deselect all
                                this.selectedTradingTypes.clear();
                                container.querySelectorAll('.exchange-chip').forEach(c => c.classList.remove('active'));
                            } else {
                                // Not all selected, select all
                                this.selectedTradingTypes = new Set(sortedTypes);
                                container.querySelectorAll('.exchange-chip').forEach(c => c.classList.add('active'));
                            }
                        } else {
                            // Individual type clicked
                            if (this.selectedTradingTypes.has(typeId)) {
                                this.selectedTradingTypes.delete(typeId);
                                chip.classList.remove('active');
                            } else {
                                this.selectedTradingTypes.add(typeId);
                                chip.classList.add('active');
                            }
                            
                            // Update "All Types" chip state
                            const allTypesChip = container.querySelector('[data-type=""]');
                            if (this.selectedTradingTypes.size === sortedTypes.length) {
                                allTypesChip.classList.add('active');
                            } else {
                                allTypesChip.classList.remove('active');
                            }
                        }
                        
                        this.applyFilters();
                    });
                });
            }

            updateFilterOptions() {
                // Define top assets to pin at the top
                const topQuoteAssets = ['USDT', 'USDC', 'BTC', 'ETH', 'BNB', 'USD'];
                const topBaseAssets = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'DOT', 'LINK', 'MATIC', 'AVAX', 'UNI'];

                // Update quote asset filter
                const allQuoteAssets = [...new Set(this.processedPairs.map(p => p.quoteAsset))];
                const pinnedQuotes = topQuoteAssets.filter(asset => allQuoteAssets.includes(asset));
                const otherQuotes = allQuoteAssets.filter(asset => !topQuoteAssets.includes(asset)).sort();
                
                this.updateDropdownOptions('quote', pinnedQuotes, otherQuotes, 'All Quote Assets');

                // Update base asset filter
                const allBaseAssets = [...new Set(this.processedPairs.map(p => p.baseAsset))];
                const pinnedBases = topBaseAssets.filter(asset => allBaseAssets.includes(asset));
                const otherBases = allBaseAssets.filter(asset => !topBaseAssets.includes(asset)).sort();
                
                this.updateDropdownOptions('base', pinnedBases, otherBases, 'All Base Assets');
            }

            setupSearchableDropdown(type) {
                const dropdown = document.getElementById(`${type}Dropdown`);
                const input = document.getElementById(`${type}Filter`);
                const options = document.getElementById(`${type}Options`);
                
                // Initialize dropdown state
                dropdown.selectedValue = '';
                dropdown.isOpen = false;
                
                // Toggle dropdown
                input.addEventListener('click', () => {
                    if (input.readOnly) {
                        this.toggleDropdown(dropdown, options);
                    }
                });
                
                // Handle search input
                input.addEventListener('input', () => {
                    if (!input.readOnly) {
                        this.filterDropdownOptions(type, input.value);
                    }
                });
                
                // Handle focus/blur for search mode
                input.addEventListener('focus', () => {
                    if (dropdown.isOpen) {
                        input.readOnly = false;
                        input.placeholder = `Search ${type} assets...`;
                    }
                });
                
                input.addEventListener('blur', (e) => {
                    // Delay to allow option click
                    setTimeout(() => {
                        if (!dropdown.contains(e.relatedTarget)) {
                            this.closeDropdown(dropdown, options, input);
                        }
                    }, 150);
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!dropdown.contains(e.target)) {
                        this.closeDropdown(dropdown, options, input);
                    }
                });
            }
            
            toggleDropdown(dropdown, options) {
                dropdown.isOpen = !dropdown.isOpen;
                dropdown.classList.toggle('open', dropdown.isOpen);
                
                if (dropdown.isOpen) {
                    options.style.display = 'block';
                } else {
                    options.style.display = 'none';
                }
            }
            
            closeDropdown(dropdown, options, input) {
                dropdown.isOpen = false;
                dropdown.classList.remove('open');
                options.style.display = 'none';
                input.readOnly = true;
                
                // Restore display value
                const selectedOption = options.querySelector('.dropdown-option.selected');
                if (selectedOption) {
                    input.value = selectedOption.textContent;
                } else {
                    input.value = '';
                    // Determine type from input id
                    const isQuote = input.id === 'quoteFilter';
                    input.placeholder = isQuote ? 'All Quote Assets' : 'All Base Assets';
                }
            }
            
            updateDropdownOptions(type, pinnedAssets, otherAssets, allLabel) {
                const options = document.getElementById(`${type}Options`);
                const dropdown = document.getElementById(`${type}Dropdown`);
                
                let html = `<div class="dropdown-option" data-value="">${allLabel}</div>`;
                
                if (pinnedAssets.length > 0) {
                    html += '<div class="dropdown-section-header">Popular</div>';
                    pinnedAssets.forEach(asset => {
                        html += `<div class="dropdown-option pinned" data-value="${asset}">${asset}</div>`;
                    });
                }
                
                if (otherAssets.length > 0) {
                    html += '<div class="dropdown-section-header">All Assets</div>';
                    otherAssets.forEach(asset => {
                        html += `<div class="dropdown-option" data-value="${asset}">${asset}</div>`;
                    });
                }
                
                options.innerHTML = html;
                
                // Add click handlers to options
                options.querySelectorAll('.dropdown-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.selectDropdownOption(type, option, dropdown);
                    });
                });
            }
            
            selectDropdownOption(type, option, dropdown) {
                const input = document.getElementById(`${type}Filter`);
                const options = document.getElementById(`${type}Options`);
                
                // Update selection
                options.querySelectorAll('.dropdown-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                
                // Update input value and dropdown state
                dropdown.selectedValue = option.dataset.value;
                input.value = option.textContent;
                
                // Close dropdown
                this.closeDropdown(dropdown, options, input);
                
                // Apply filters
                this.applyFilters();
            }
            
            filterDropdownOptions(type, searchTerm) {
                const options = document.getElementById(`${type}Options`);
                const allOptions = options.querySelectorAll('.dropdown-option');
                const headers = options.querySelectorAll('.dropdown-section-header');
                
                searchTerm = searchTerm.toLowerCase();
                
                allOptions.forEach(option => {
                    const text = option.textContent.toLowerCase();
                    const matches = text.includes(searchTerm) || option.dataset.value === '';
                    option.style.display = matches ? 'block' : 'none';
                });
                
                // Hide/show section headers based on visible options
                headers.forEach(header => {
                    const nextOptions = [];
                    let nextElement = header.nextElementSibling;
                    while (nextElement && !nextElement.classList.contains('dropdown-section-header')) {
                        if (nextElement.classList.contains('dropdown-option')) {
                            nextOptions.push(nextElement);
                        }
                        nextElement = nextElement.nextElementSibling;
                    }
                    
                    const hasVisibleOptions = nextOptions.some(opt => opt.style.display !== 'none');
                    header.style.display = hasVisibleOptions ? 'block' : 'none';
                });
            }

            applyFilters() {
                const searchTerm = document.getElementById('searchInput').value.toLowerCase();
                const sortBy = document.getElementById('sortBy').value;
                const quoteDropdown = document.getElementById('quoteDropdown');
                const baseDropdown = document.getElementById('baseDropdown');
                const quoteFilter = quoteDropdown ? quoteDropdown.selectedValue || '' : '';
                const baseFilter = baseDropdown ? baseDropdown.selectedValue || '' : '';

                // Filter pairs
                this.filteredPairs = this.processedPairs.filter(pair => {
                    // Search filter
                    if (searchTerm && !pair.symbol.toLowerCase().includes(searchTerm) && 
                        !pair.baseAsset.toLowerCase().includes(searchTerm) && 
                        !pair.quoteAsset.toLowerCase().includes(searchTerm)) {
                        return false;
                    }

                    // Quote asset filter
                    if (quoteFilter && pair.quoteAsset !== quoteFilter) {
                        return false;
                    }

                    // Base asset filter
                    if (baseFilter && pair.baseAsset !== baseFilter) {
                        return false;
                    }

                    // Exchange filter
                    if (!pair.exchanges.some(exchange => this.selectedExchanges.has(exchange.id))) {
                        return false;
                    }

                    // Trading type filter - check if any of the pair's types are selected
                    if (this.selectedTradingTypes.size > 0 && 
                        !Array.from(pair.tradingTypes).some(type => this.selectedTradingTypes.has(type))) {
                        return false;
                    }

                    return true;
                });

                // Sort pairs
                this.filteredPairs.sort((a, b) => {
                    switch (sortBy) {
                        case 'symbol':
                            return a.symbol.localeCompare(b.symbol);
                        case 'exchanges':
                            return b.exchangeCount - a.exchangeCount;
                        case 'volume':
                            const aVolume = a.volumeData?.volumeUSD || 0;
                            const bVolume = b.volumeData?.volumeUSD || 0;
                            return bVolume - aVolume; // Descending order (highest volume first)
                        case 'baseAsset':
                            return a.baseAsset.localeCompare(b.baseAsset);
                        case 'quoteAsset':
                            return a.quoteAsset.localeCompare(b.quoteAsset);
                        case 'tradingType':
                            const aType = Array.from(a.tradingTypes)[0] || '';
                            const bType = Array.from(b.tradingTypes)[0] || '';
                            return aType.localeCompare(bType);
                        default:
                            return 0;
                    }
                });

                this.updateTable();
            }

            updateTable() {
                const tbody = document.getElementById('pairsTableBody');
                const resultsCount = document.getElementById('resultsCount');

                resultsCount.textContent = `${this.filteredPairs.length} pairs`;

                if (this.filteredPairs.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; padding: 40px; color: #666;">No trading pairs match your filters</td></tr>';
                    return;
                }

                tbody.innerHTML = this.filteredPairs.map(pair => `
                    <tr>
                        <td class="symbol-cell">${pair.symbol}</td>
                        <td>${pair.baseAsset}</td>
                        <td>${pair.quoteAsset}</td>
                        <td>${Array.from(pair.tradingTypes).map(type => 
                            `<span class="trading-type-badge ${type}">${type}</span>`
                        ).join('')}</td>
                        <td class="volume-cell">
                            ${this.renderVolumeData(pair)}
                        </td>
                        <td>
                            ${pair.exchanges.map(exchange => `
                                <span class="exchange-badge" style="background-color: ${this.exchangeColors[exchange.id] || '#6c757d'}">
                                    ${exchange.name}
                                </span>
                            `).join('')}
                        </td>
                        <td><strong>${pair.exchangeCount}</strong></td>
                    </tr>
                `).join('');
            }

            // Volume-related methods
            isFuturesContract(symbol) {
                // Check if symbol contains date patterns like 04JUL25, 11JUL25, etc.
                const datePattern = /\d{2}[A-Z]{3}\d{2}$/;
                return datePattern.test(symbol);
            }

            startVolumeUpdates() {
                // Initial load of volume data for visible pairs
                this.updateVolumeData();
                
                // Set up periodic updates every 30 seconds
                this.volumeUpdateInterval = setInterval(() => {
                    this.updateVolumeData();
                }, 30000);
            }

            async updateVolumeData() {
                // Update volume for top pairs first (most visible)
                // Filter out futures contracts with expiry dates
                const topPairs = this.filteredPairs.slice(0, 20).filter(pair => {
                    // Skip futures contracts with dates (e.g., BTCUSDT04JUL25)
                    return !this.isFuturesContract(pair.symbol);
                });
                
                for (const pair of topPairs) {
                    if (!pair.volumeData || pair.volumeData.status !== 'loading') {
                        await this.fetchVolumeForPair(pair);
                    }
                }
                
                // Update the table to reflect new volume data
                this.updateTable();
            }

            async fetchVolumeForPair(pair) {
                const cacheKey = pair.symbol;
                const cached = this.volumeCache.get(cacheKey);
                
                // Check if cached data is still fresh (less than 2 minutes old)
                if (cached && cached.status === 'success') {
                    const age = Date.now() - new Date(cached.lastUpdated).getTime();
                    if (age < 120000) { // 2 minutes
                        pair.volumeData = cached;
                        return;
                    }
                }

                // Set loading state
                pair.volumeData = {
                    volume24h: 0,
                    volumeUSD: 0,
                    lastUpdated: new Date().toISOString(),
                    timeframe: '24h',
                    status: 'loading'
                };

                try {
                    // Find the best exchange for volume data (prefer Binance, Bybit, OKX)
                    const preferredExchanges = ['binance', 'bybit', 'okx'];
                    let bestExchange = pair.exchanges[0]; // fallback to first
                    
                    for (const exchange of pair.exchanges) {
                        if (preferredExchanges.includes(exchange.id)) {
                            bestExchange = exchange;
                            break;
                        }
                    }
                    
                    const volumeData = await this.fetchVolumeFromExchange(bestExchange.id, pair.symbol);
                    
                    const volume = {
                        volume24h: volumeData.volume,
                        volumeUSD: volumeData.volumeUSD,
                        lastUpdated: new Date().toISOString(),
                        timeframe: '24h',
                        status: 'success'
                    };

                    pair.volumeData = volume;
                    this.volumeCache.set(cacheKey, volume);
                    
                } catch (error) {
                    const errorData = {
                        volume24h: 0,
                        volumeUSD: 0,
                        lastUpdated: new Date().toISOString(),
                        timeframe: '24h',
                        status: 'error',
                        error: error.message
                    };
                    
                    pair.volumeData = errorData;
                    this.volumeCache.set(cacheKey, errorData);
                }
            }

            async fetchVolumeFromExchange(exchangeId, symbol) {
                switch (exchangeId) {
                    case 'binance':
                        return this.fetchBinanceVolume(symbol);
                    case 'bybit':
                        return this.fetchBybitVolume(symbol);
                    case 'okx':
                        return this.fetchOkxVolume(symbol);
                    default:
                        // For other exchanges, return simulated data
                        return this.generateSimulatedVolume(symbol);
                }
            }

            async fetchBinanceVolume(symbol) {
                try {
                    // Skip futures contracts
                    if (this.isFuturesContract(symbol)) {
                        return this.generateSimulatedVolume(symbol);
                    }
                    
                    const response = await fetch(`https://fapi.binance.com/fapi/v1/ticker/24hr?symbol=${symbol}`);
                    if (!response.ok) throw new Error(`Binance API error: ${response.status}`);
                    
                    const data = await response.json();
                    return {
                        volume: parseFloat(data.volume) || 0,
                        volumeUSD: parseFloat(data.quoteVolume) || 0
                    };
                } catch (error) {
                    // Don't log warnings for futures contracts
                    if (!this.isFuturesContract(symbol)) {
                        console.warn(`Failed to fetch Binance volume for ${symbol}:`, error);
                    }
                    return this.generateSimulatedVolume(symbol);
                }
            }

            async fetchBybitVolume(symbol) {
                try {
                    // Skip futures contracts
                    if (this.isFuturesContract(symbol)) {
                        return this.generateSimulatedVolume(symbol);
                    }
                    
                    const response = await fetch(`https://api.bybit.com/v5/market/tickers?category=linear&symbol=${symbol}`);
                    if (!response.ok) throw new Error(`Bybit API error: ${response.status}`);
                    
                    const data = await response.json();
                    const ticker = data.result?.list?.[0];
                    if (!ticker) {
                        // Try with spot category instead
                        const spotResponse = await fetch(`https://api.bybit.com/v5/market/tickers?category=spot&symbol=${symbol}`);
                        if (spotResponse.ok) {
                            const spotData = await spotResponse.json();
                            const spotTicker = spotData.result?.list?.[0];
                            if (spotTicker) {
                                return {
                                    volume: parseFloat(spotTicker.volume24h) || 0,
                                    volumeUSD: parseFloat(spotTicker.turnover24h) || 0
                                };
                            }
                        }
                        throw new Error('No ticker data');
                    }
                    
                    return {
                        volume: parseFloat(ticker.volume24h) || 0,
                        volumeUSD: parseFloat(ticker.turnover24h) || 0
                    };
                } catch (error) {
                    // Don't log warnings for futures contracts
                    if (!this.isFuturesContract(symbol)) {
                        console.warn(`Failed to fetch Bybit volume for ${symbol}:`, error);
                    }
                    return this.generateSimulatedVolume(symbol);
                }
            }

            async fetchOkxVolume(symbol) {
                try {
                    // Skip futures contracts
                    if (this.isFuturesContract(symbol)) {
                        return this.generateSimulatedVolume(symbol);
                    }
                    
                    // Convert symbol format for OKX (e.g., BTCUSDT -> BTC-USDT-SWAP)
                    const base = symbol.replace('USDT', '');
                    const okxSymbol = `${base}-USDT-SWAP`;
                    
                    const response = await fetch(`https://www.okx.com/api/v5/market/ticker?instId=${okxSymbol}`);
                    if (!response.ok) throw new Error(`OKX API error: ${response.status}`);
                    
                    const data = await response.json();
                    const ticker = data.data?.[0];
                    if (!ticker) throw new Error('No ticker data');
                    
                    return {
                        volume: parseFloat(ticker.vol24h) || 0,
                        volumeUSD: parseFloat(ticker.volCcy24h) || 0
                    };
                } catch (error) {
                    // Don't log warnings for futures contracts
                    if (!this.isFuturesContract(symbol)) {
                        console.warn(`Failed to fetch OKX volume for ${symbol}:`, error);
                    }
                    return this.generateSimulatedVolume(symbol);
                }
            }

            generateSimulatedVolume(symbol) {
                // Generate realistic-looking volume data based on symbol popularity
                const popularSymbols = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'ADAUSDT'];
                const isPopular = popularSymbols.includes(symbol);
                
                const baseVolume = isPopular ? 
                    Math.random() * 50000 + 10000 : // 10K-60K for popular
                    Math.random() * 5000 + 500;     // 500-5.5K for others
                
                const price = isPopular ? 
                    Math.random() * 50000 + 1000 :  // Simulated price
                    Math.random() * 100 + 1;
                
                return {
                    volume: Math.floor(baseVolume),
                    volumeUSD: Math.floor(baseVolume * price)
                };
            }

            renderVolumeData(pair) {
                // Skip volume for futures contracts
                if (this.isFuturesContract(pair.symbol)) {
                    return '<div class="volume-error">Futures</div>';
                }
                
                if (!pair.volumeData) {
                    return '<div class="volume-loading">Loading...</div>';
                }

                const { volumeData } = pair;

                switch (volumeData.status) {
                    case 'loading':
                        return '<div class="volume-loading">Loading...</div>';
                        
                    case 'error':
                        return '<div class="volume-error">N/A</div>';
                        
                    case 'success':
                        const volumeClass = this.getVolumeClass(volumeData.volumeUSD);
                        const formattedVolume = this.formatVolume(volumeData.volumeUSD);
                        const timeAgo = this.getTimeAgo(volumeData.lastUpdated);
                        
                        return `
                            <div class="volume-data">
                                <div class="volume-amount ${volumeClass}">$${formattedVolume}</div>
                                <div class="volume-meta">
                                    <span class="volume-timeframe">${volumeData.timeframe}</span>
                                    <span class="volume-updated">${timeAgo}</span>
                                </div>
                            </div>
                        `;
                        
                    default:
                        return '<div class="volume-error">N/A</div>';
                }
            }

            getVolumeClass(volumeUSD) {
                if (volumeUSD > 10000000) return 'high';   // > $10M
                if (volumeUSD > 1000000) return 'medium';  // > $1M
                return 'low';
            }

            formatVolume(volume) {
                if (volume >= 1e9) return (volume / 1e9).toFixed(1) + 'B';
                if (volume >= 1e6) return (volume / 1e6).toFixed(1) + 'M';
                if (volume >= 1e3) return (volume / 1e3).toFixed(1) + 'K';
                return volume.toFixed(0);
            }

            getTimeAgo(timestamp) {
                const diff = Date.now() - new Date(timestamp).getTime();
                const minutes = Math.floor(diff / 60000);
                
                if (minutes < 1) return 'now';
                if (minutes < 60) return `${minutes}m ago`;
                
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours}h ago`;
                
                const days = Math.floor(hours / 24);
                return `${days}d ago`;
            }

            showError(message) {
                const container = document.querySelector('.container');
                container.innerHTML = `
                    <div class="header">
                        <h1>üöÄ Trading Pairs Explorer</h1>
                        <p>Comprehensive trading pairs data across all supported exchanges</p>
                    </div>
                    <div class="error">
                        <strong>Error:</strong> ${message}
                    </div>
                `;
            }
        }

        // Initialize the explorer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new TradingPairsExplorer();
        });
    </script>
</body>
</html> 